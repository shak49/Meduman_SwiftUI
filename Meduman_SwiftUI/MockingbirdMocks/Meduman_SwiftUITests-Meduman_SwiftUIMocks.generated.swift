//
//  Meduman_SwiftUITests-Meduman_SwiftUIMocks.generated.swift
//  Meduman_SwiftUI
//
//  Generated by Mockingbird v0.20.0.
//  DO NOT EDIT
//

@testable import Meduman_SwiftUI
@testable import Mockingbird
import Combine
import Firebase
import FirebaseAuth
import FirebaseFirestore
import FirebaseFirestoreSwift
import Foundation
import HealthKit
import Mockingbird
import Swift
import SwiftUI
import UIKit
import XCTest

private let mkbGenericStaticMockContext = Mockingbird.GenericStaticMockContext()

// MARK: - Mocked URLSessionDataTaskPublisherProtocol
public final class URLSessionDataTaskPublisherProtocolMock: Meduman_SwiftUI.URLSessionDataTaskPublisherProtocol, Mockingbird.Mock {
  typealias MockingbirdSupertype = Meduman_SwiftUI.URLSessionDataTaskPublisherProtocol
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "Meduman_SwiftUI"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    URLSessionDataTaskPublisherProtocolMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `sink`(`receiveCompletion`: @escaping (Subscribers.Completion<URLError>) -> Void, `receiveValue`: @escaping ((data: Data, response: URLResponse)) -> Void)
  public func `sink`(`receiveCompletion`: @escaping (Subscribers.Completion<URLError>) -> Void, `receiveValue`: @escaping ((data: Data, response: URLResponse)) -> Void) -> AnyCancellable {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`sink`(`receiveCompletion`: @escaping (Subscribers.Completion<URLError>) -> Void, `receiveValue`: @escaping ((data: Data, response: URLResponse)) -> Void) -> AnyCancellable", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`receiveCompletion`), Mockingbird.ArgumentMatcher(`receiveValue`)], returnType: Swift.ObjectIdentifier((AnyCancellable).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (@escaping (Subscribers.Completion<URLError>) -> Void, @escaping ((data: Data, response: URLResponse)) -> Void) -> AnyCancellable { return mkbImpl(`receiveCompletion`, `receiveValue`) }
      if let mkbImpl = mkbImpl as? () -> AnyCancellable { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: AnyCancellable = mkbObject.`sink`(receiveCompletion: `receiveCompletion`, receiveValue: `receiveValue`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (AnyCancellable).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `sink`(`receiveCompletion`: @autoclosure () -> (Subscribers.Completion<URLError>) -> Void, `receiveValue`: @autoclosure () -> ((data: Data, response: URLResponse)) -> Void) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping (Subscribers.Completion<URLError>) -> Void, @escaping ((data: Data, response: URLResponse)) -> Void) -> AnyCancellable, AnyCancellable> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping (Subscribers.Completion<URLError>) -> Void, @escaping ((data: Data, response: URLResponse)) -> Void) -> AnyCancellable, AnyCancellable>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`sink`(`receiveCompletion`: @escaping (Subscribers.Completion<URLError>) -> Void, `receiveValue`: @escaping ((data: Data, response: URLResponse)) -> Void) -> AnyCancellable", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`receiveCompletion`), Mockingbird.resolve(`receiveValue`)], returnType: Swift.ObjectIdentifier((AnyCancellable).self)))
  }

  // MARK: Mocked `map`<T>(_ `transform`: @escaping ((data: Data, response: URLResponse)) -> T)
  public func `map`<T>(_ `transform`: @escaping ((data: Data, response: URLResponse)) -> T) -> Publishers.Map<URLSession.DataTaskPublisher, T> {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`map`<T>(_ `transform`: @escaping ((data: Data, response: URLResponse)) -> T) -> Publishers.Map<URLSession.DataTaskPublisher, T>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`transform`)], returnType: Swift.ObjectIdentifier((Publishers.Map<URLSession.DataTaskPublisher, T>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (@escaping ((data: Data, response: URLResponse)) -> T) -> Publishers.Map<URLSession.DataTaskPublisher, T> { return mkbImpl(`transform`) }
      if let mkbImpl = mkbImpl as? () -> Publishers.Map<URLSession.DataTaskPublisher, T> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Publishers.Map<URLSession.DataTaskPublisher, T> = mkbObject.`map`(`transform`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Publishers.Map<URLSession.DataTaskPublisher, T>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `map`<T>(_ `transform`: @autoclosure () -> ((data: Data, response: URLResponse)) -> T) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping ((data: Data, response: URLResponse)) -> T) -> Publishers.Map<URLSession.DataTaskPublisher, T>, Publishers.Map<URLSession.DataTaskPublisher, T>> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping ((data: Data, response: URLResponse)) -> T) -> Publishers.Map<URLSession.DataTaskPublisher, T>, Publishers.Map<URLSession.DataTaskPublisher, T>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`map`<T>(_ `transform`: @escaping ((data: Data, response: URLResponse)) -> T) -> Publishers.Map<URLSession.DataTaskPublisher, T>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`transform`)], returnType: Swift.ObjectIdentifier((Publishers.Map<URLSession.DataTaskPublisher, T>).self)))
  }

  // MARK: Mocked `mapError`<E>(_ `transform`: @escaping (URLError) -> E)
  public func `mapError`<E>(_ `transform`: @escaping (URLError) -> E) -> Publishers.MapError<URLSession.DataTaskPublisher, E> where E: Error {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`mapError`<E>(_ `transform`: @escaping (URLError) -> E) -> Publishers.MapError<URLSession.DataTaskPublisher, E> where E: Error", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`transform`)], returnType: Swift.ObjectIdentifier((Publishers.MapError<URLSession.DataTaskPublisher, E>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (@escaping (URLError) -> E) -> Publishers.MapError<URLSession.DataTaskPublisher, E> { return mkbImpl(`transform`) }
      if let mkbImpl = mkbImpl as? () -> Publishers.MapError<URLSession.DataTaskPublisher, E> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Publishers.MapError<URLSession.DataTaskPublisher, E> = mkbObject.`mapError`(`transform`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Publishers.MapError<URLSession.DataTaskPublisher, E>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `mapError`<E>(_ `transform`: @autoclosure () -> (URLError) -> E) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping (URLError) -> E) -> Publishers.MapError<URLSession.DataTaskPublisher, E>, Publishers.MapError<URLSession.DataTaskPublisher, E>> where E: Error {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (@escaping (URLError) -> E) -> Publishers.MapError<URLSession.DataTaskPublisher, E>, Publishers.MapError<URLSession.DataTaskPublisher, E>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`mapError`<E>(_ `transform`: @escaping (URLError) -> E) -> Publishers.MapError<URLSession.DataTaskPublisher, E> where E: Error", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`transform`)], returnType: Swift.ObjectIdentifier((Publishers.MapError<URLSession.DataTaskPublisher, E>).self)))
  }

  // MARK: Mocked `receive`<S>(on `scheduler`: S, `options`: S.SchedulerOptions?)
  public func `receive`<S>(on `scheduler`: S, `options`: S.SchedulerOptions?) -> Publishers.ReceiveOn<URLSession.DataTaskPublisher, S> where S: Scheduler {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`receive`<S>(on `scheduler`: S, `options`: S.SchedulerOptions?) -> Publishers.ReceiveOn<URLSession.DataTaskPublisher, S> where S: Scheduler", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`scheduler`), Mockingbird.ArgumentMatcher(`options`)], returnType: Swift.ObjectIdentifier((Publishers.ReceiveOn<URLSession.DataTaskPublisher, S>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (S, S.SchedulerOptions?) -> Publishers.ReceiveOn<URLSession.DataTaskPublisher, S> { return mkbImpl(`scheduler`, `options`) }
      if let mkbImpl = mkbImpl as? () -> Publishers.ReceiveOn<URLSession.DataTaskPublisher, S> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Publishers.ReceiveOn<URLSession.DataTaskPublisher, S> = mkbObject.`receive`(on: `scheduler`, options: `options`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Publishers.ReceiveOn<URLSession.DataTaskPublisher, S>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `receive`<S>(on `scheduler`: @autoclosure () -> S, `options`: @autoclosure () -> S.SchedulerOptions?) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (S, S.SchedulerOptions?) -> Publishers.ReceiveOn<URLSession.DataTaskPublisher, S>, Publishers.ReceiveOn<URLSession.DataTaskPublisher, S>> where S: Scheduler {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (S, S.SchedulerOptions?) -> Publishers.ReceiveOn<URLSession.DataTaskPublisher, S>, Publishers.ReceiveOn<URLSession.DataTaskPublisher, S>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`receive`<S>(on `scheduler`: S, `options`: S.SchedulerOptions?) -> Publishers.ReceiveOn<URLSession.DataTaskPublisher, S> where S: Scheduler", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`scheduler`), Mockingbird.resolve(`options`)], returnType: Swift.ObjectIdentifier((Publishers.ReceiveOn<URLSession.DataTaskPublisher, S>).self)))
  }
}

/// Returns a concrete mock of `URLSessionDataTaskPublisherProtocol`.
public func mock(_ type: Meduman_SwiftUI.URLSessionDataTaskPublisherProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> URLSessionDataTaskPublisherProtocolMock {
  return URLSessionDataTaskPublisherProtocolMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked URLSessionProtocol
public final class URLSessionProtocolMock: Meduman_SwiftUI.URLSessionProtocol, Mockingbird.Mock {
  typealias MockingbirdSupertype = Meduman_SwiftUI.URLSessionProtocol
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "Meduman_SwiftUI"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    URLSessionProtocolMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `dataTaskPublisher`(`for`: URLRequest)
  public func `dataTaskPublisher`(`for`: URLRequest) -> URLSession.DataTaskPublisher {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`dataTaskPublisher`(`for`: URLRequest) -> URLSession.DataTaskPublisher", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`for`)], returnType: Swift.ObjectIdentifier((URLSession.DataTaskPublisher).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (URLRequest) -> URLSession.DataTaskPublisher { return mkbImpl(`for`) }
      if let mkbImpl = mkbImpl as? () -> URLSession.DataTaskPublisher { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: URLSession.DataTaskPublisher = mkbObject.`dataTaskPublisher`(for: `for`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (URLSession.DataTaskPublisher).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `dataTaskPublisher`(`for`: @autoclosure () -> URLRequest) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (URLRequest) -> URLSession.DataTaskPublisher, URLSession.DataTaskPublisher> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (URLRequest) -> URLSession.DataTaskPublisher, URLSession.DataTaskPublisher>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`dataTaskPublisher`(`for`: URLRequest) -> URLSession.DataTaskPublisher", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`for`)], returnType: Swift.ObjectIdentifier((URLSession.DataTaskPublisher).self)))
  }
}

/// Returns a concrete mock of `URLSessionProtocol`.
public func mock(_ type: Meduman_SwiftUI.URLSessionProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> URLSessionProtocolMock {
  return URLSessionProtocolMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}
